package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"regexp"
)

// Generates CRDs for Helm Chart charts/kong-operator/templates/validating-webhook.yaml.
func main() {
	const autoGenerationComment = "# This file is auto-generated by KO's hack/generators/validating-webhook/main.go generator.\n"

	const chartCRDsFilePath = "charts/kong-operator/templates/validating-webhook.yaml"
	fmt.Println("Generating", chartCRDsFilePath)
	KUSTOMIZE_BIN := os.Getenv("KUSTOMIZE_BIN")
	if KUSTOMIZE_BIN == "" {
		fmt.Println("KUSTOMIZE_BIN environment variable is not set")
		os.Exit(1)
	}
	fmt.Println("KUSTOMIZE_BIN is set to:", KUSTOMIZE_BIN)

	ctx := context.Background()
	cmd := exec.CommandContext(ctx, KUSTOMIZE_BIN, "build", "config/default/validating_webhook/")
	var out bytes.Buffer
	cmd.Stdout = &out
	if err := cmd.Run(); err != nil {
		fmt.Printf("Failed to execute %s: %v\n", cmd.String(), err)
		os.Exit(1)
	}
	crdContent := out.String()

	crdContent = wrapInIfWebhookEnabled(crdContent)
	crdContent = templateNamespace(crdContent)
	crdContent = templateLabels(crdContent)
	crdContent = templateInjectCAAnnotationForCertManager(crdContent)

	var fileCRDs *os.File
	fileCRDs, err := os.Create(chartCRDsFilePath)
	if err != nil {
		fmt.Printf("Failed to create %s: %v\n", chartCRDsFilePath, err)
		os.Exit(1)
	}
	defer fileCRDs.Close()

	for _, content := range []string{autoGenerationComment, selfSignedCertSecretTemplate, crdContent} {
		if _, err := fileCRDs.WriteString(content); err != nil {
			fmt.Printf("Failed to write to %s: %v\n", chartCRDsFilePath, err)
			os.Exit(1)
		}
	}
	fileCRDs.Close()

	fmt.Println("Successfully finished")
}

func wrapInIfWebhookEnabled(v string) string {
	// NOTE: This values.yaml field path must match the one in
	// https://github.com/Kong/kong-operator/blob/f981b357ff58dd71ff2f5eac1330f3f1693d2734/charts/kong-operator/values.yaml#L140
	return fmt.Sprintf("{{- if .Values.global.webhooks.validating.enabled }}\n%s\n{{- end }}\n", v)
}

func templateNamespace(yaml string) string {
	// Regex to match the clientConfig.service block
	re := regexp.MustCompile(`(?ms)clientConfig:\s*service:.*?port:\s*(\d+)`)

	// Replacement with Helm template
	replacement := `clientConfig:
    service:
      name: {{ template "kong.webhookServiceName" . }}
      namespace: {{ template "kong.namespace" . }}
      port: $1
{{- if not .Values.global.webhooks.options.certManager.enabled }}
    caBundle: |
      {{ $$caCert | b64enc }}
{{- end }}`

	// Perform replacement
	return re.ReplaceAllString(yaml, replacement)
}

func templateLabels(yaml string) string {
	// Regex matches "labels:" followed by indented lines
	// - labels:\s* matches the key
	// - (?:\n\s+.*)* matches any number of following indented lines
	re := regexp.MustCompile(`(?m)labels:\s*(?:\n\s+.*)*`)

	// Replacement: inject Helm template
	replacement := `labels:
    {{- include "kong.metaLabels" . | nindent 4 }}
    `

	// Perform replacement
	return re.ReplaceAllString(yaml, replacement)
}

func templateInjectCAAnnotationForCertManager(yaml string) string {
	// Regex to match the annotations block containing cert-manager.io/inject-ca-from
	re := regexp.MustCompile(`(?m)^  annotations:\n(?:    .*\n)+?  labels:`)

	// Replacement block with Helm templating
	replacement := `{{- if .Values.global.webhooks.options.certManager.enabled }}
  annotations:
    cert-manager.io/inject-ca-from: {{ template "kong.namespace" . }}/{{ template "kong.webhookServiceName" . }}-serving-cert
    cert-manager.io/secret-template: '{ "labels": { "konghq.com/secret" : "true" } }'
{{- end }}
  labels:`

	return re.ReplaceAllString(yaml, replacement)
}

const (
	// selfSignedCertSecretTemplate contains the template for the self-signed
	// certificate secret.
	// This allows users to not require cert-manager for certificates management.
	// It is embedded in manifest file containing CRD definitions because it's not
	// possible to place that in a separate file, and use the lookup function
	// (for the Secret) in the CRD definition file due to the Secret not being
	// applied yet at that time.
	// Helm hooks and their priority do not seem to help here either.
	selfSignedCertSecretTemplate = `
{{ $name := ( include "kong.webhookValidatingCertSecretName" .) }}
{{ $secret := (lookup "v1" "Secret" .Release.Namespace $name) }}
{{ $serviceName := (include "kong.webhookServiceName" .) }}
{{ $namespace := (include "kong.namespace" .) }}
{{ $domainName := ( printf "%s.%s.svc" $serviceName $namespace ) }}
{{ $domainNameClusterLocal := ( printf "%s.%s.svc.cluster.local" $serviceName $namespace ) }}
{{ $dnsNames := list ($domainName) ($domainNameClusterLocal) }}

{{ $ca := genCA "" 3650 }}
{{ $cert := genSignedCert $domainName nil $dnsNames 3650 $ca }}
{{ $certCert := $cert.Cert }}
{{ $certKey := $cert.Key }}
{{ $caCert := $ca.Cert }}
{{ if $secret }}
{{ $certCert = (index $secret.data "tls.crt" ) | b64dec }}
{{ $certKey = (index $secret.data "tls.key" ) | b64dec }}
{{ $caCert = (index $secret.data "ca.crt" ) | b64dec }}
{{- end }}

{{- if .Values.global.webhooks.validating.enabled }}
{{- if ( not .Values.global.webhooks.options.certManager.enabled ) }}
apiVersion: v1
kind: Secret
metadata:
  labels:
    {{- include "kong.metaLabels" . | nindent 4 }}
    app.kubernetes.io/component: ko
  annotations:
    dnsNames: {{ join "," $dnsNames | quote }}
  name: {{ $name }}
  namespace: {{ template "kong.namespace" . }}
type: kubernetes.io/tls
stringData:
  ca.crt: |
    {{ $caCert | nindent 4 }}
  tls.crt: |
    {{ $certCert | nindent 4 }}
  tls.key: |
    {{ $certKey | nindent 4 }}
{{- end }}
{{- end }}
---
`
)
