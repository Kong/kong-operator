package main

import (
	admregv1 "k8s.io/api/admissionregistration/v1"
)

type singleVersionTemplateData struct {
	VersionConstraint          string
	SanitizedVersionConstraint string
	Webhooks                   []admregv1.ValidatingWebhook
}

var generateValidatingWebhookConfigurationForKICVersionTemplate = `// This file is generated by /hack/generators/kic/webhook-config-generator. DO NOT EDIT.

package validatingwebhookconfig

import (
	"github.com/samber/lo"
	admregv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// GenerateValidatingWebhookConfigurationForKIC_{{ .SanitizedVersionConstraint }} generates a ValidatingWebhookConfiguration for KIC {{ .VersionConstraint }}.
func GenerateValidatingWebhookConfigurationForKIC_{{ .SanitizedVersionConstraint }}(name string, clientConfig admregv1.WebhookClientConfig) *admregv1.ValidatingWebhookConfiguration {
	return &admregv1.ValidatingWebhookConfiguration{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
		Webhooks: []admregv1.ValidatingWebhook{
			{{- range .Webhooks }}
			{
				Name: "{{ .Name }}",
				ClientConfig: clientConfig,
				// We're using 'Ignore' failure policy to avoid issues with modifying resources when webhook-backing
				// Deployments (ControlPlane and DataPlane) are not available.
				// See https://github.com/kong/kong-operator/issues/1564 for more details.
				FailurePolicy: lo.ToPtr(admregv1.Ignore),
				MatchPolicy: lo.ToPtr(admregv1.MatchPolicyType("{{ .MatchPolicy }}")),
				SideEffects:   lo.ToPtr(admregv1.SideEffectClass("{{ .SideEffects }}")),
				AdmissionReviewVersions: []string{
					{{- range .AdmissionReviewVersions }}
					"{{ . }}",
					{{- end }}
				},
				Rules: []admregv1.RuleWithOperations{
					{{- range .Rules }}
					{
						Rule: admregv1.Rule{
							APIGroups: []string{
								{{- range .APIGroups }}
								"{{ . }}",
								{{- end }}
							},
							APIVersions: []string{
								{{- range .APIVersions }}
								"{{ . }}",
								{{- end }}
							},
							Resources: []string{
								{{- range .Resources }}
								"{{ . }}",
								{{- end }}
							},
						},
						Operations: []admregv1.OperationType{
							{{- range .Operations }}
							"{{ . }}",
							{{- end }}
						},
					},
					{{- end }}
				},
			},
			{{- end }}
		},
	}
}
`

type masterTemplateData struct {
	Constraints map[string]string // VersionConstraint -> SanitizedVersionConstraint
}

var generateValidatingWebhookConfigurationForKICVersionMasterTemplate = `// This file is generated by /hack/generators/kic/webhook-config-generator. DO NOT EDIT.

package resources

import (
	"fmt"

	"github.com/Masterminds/semver"
	semverv4 "github.com/kong/semver/v4"
	admregv1 "k8s.io/api/admissionregistration/v1"
	pkgapisadmregv1 "k8s.io/kubernetes/pkg/apis/admissionregistration/v1"

	webhook "github.com/kong/kong-operator/pkg/utils/kubernetes/resources/validatingwebhookconfig"
	"github.com/kong/kong-operator/internal/versions"
)

// GenerateValidatingWebhookConfigurationForControlPlane generates a ValidatingWebhookConfiguration for a control plane
// based on the control plane version. It also overrides all webhooks' client configurations with the provided service
// details.
func GenerateValidatingWebhookConfigurationForControlPlane(webhookName string, image string, validateControlPlaneImage bool, clientConfig admregv1.WebhookClientConfig) (*admregv1.ValidatingWebhookConfiguration, error) {
	if webhookName == "" {
		return nil, fmt.Errorf("webhook name is required")
	}
	if image == "" {
		return nil, fmt.Errorf("control plane image required")
	}

	// In dev mode we run in unsafe mode, to allow trying nightly or testing versions
	// of the controlplane. When an invalid or unsupported image is used in dev mode,
	// the clusterRole associated to the default ControlPlane image is used instead.
	v, err := versions.FromImage(image)
	if err != nil && validateControlPlaneImage {
		return nil, err
	}

	supported, err := versions.IsControlPlaneImageVersionSupported(image)
	if err != nil && validateControlPlaneImage {
		return nil, err
	}
	if validateControlPlaneImage && !supported {
		return nil, ErrControlPlaneVersionNotSupported
	}
	if !validateControlPlaneImage && !supported {
		v, err = semverv4.Parse(versions.DefaultControlPlaneVersion)
		if err != nil {
			return nil, fmt.Errorf("error when creating semver from the default controlplane version: %w", err)
		}
	}

	semVersion, err := semver.NewVersion(v.String())
	if err != nil {
		return nil, err
	}

	var constraint *semver.Constraints
	{{ range $constraint, $suffix := .Constraints}}
	constraint, err = semver.NewConstraint("{{ $constraint }}")
	if err != nil {
		return nil, err
	}
	if constraint.Check(semVersion) {
		cfg := webhook.GenerateValidatingWebhookConfigurationForKIC_{{ $suffix }}(webhookName, clientConfig)
		pkgapisadmregv1.SetObjectDefaults_ValidatingWebhookConfiguration(cfg)
		LabelObjectAsControlPlaneManaged(cfg)
		return cfg, nil
	}
	{{ end}}

	return nil, ErrControlPlaneVersionNotSupported
}
`
