package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/kong/kong-operator/internal/webhook/conversion"
	"github.com/samber/lo"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// Updates the file config/crd/patches/zz_generated_conversion_webhook.yaml
// and based on kustomize config/crd generates CRDs for Helm Chart
// charts/kong-operator/charts/ko-crds/templates/ko-crds.yaml.
func main() {
	const autoGenerationComment = "# This file is auto-generated by KO's hack/generators/conversion-webhook/main.go generator.\n"

	const kustomizePatchFilePath = "config/crd/patches/zz_generated_conversion_webhook.yaml"
	fmt.Println("Generating", kustomizePatchFilePath)
	fileKustomizePatch, err := os.Create(kustomizePatchFilePath)
	if err != nil {
		fmt.Printf("Failed to create %s: %v\n", kustomizePatchFilePath, err)
		os.Exit(1)
	}
	defer fileKustomizePatch.Close()

	if _, err := fileKustomizePatch.WriteString(autoGenerationComment); err != nil {
		fmt.Printf("Failed to write to %s: %v\n", kustomizePatchFilePath, err)
		os.Exit(1)
	}

	for _, wh := range conversion.WebhooksToSetup {
		if lo.IsEmpty(wh.GVR) {
			fmt.Printf("GVR is empty for type %T, fix it in the code\n", wh.ForType)
			os.Exit(1)
		}
		patchesForCRDs := fullKustomizePatchConfiguration(wh.GVR.GroupResource())
		if _, err := fileKustomizePatch.WriteString(patchesForCRDs); err != nil {
			fmt.Printf("Failed to write to %s: %v\n", kustomizePatchFilePath, err)
			os.Exit(1)
		}
	}

	const chartCRDsFilePath = "charts/kong-operator/charts/ko-crds/templates/ko-crds.yaml"
	fmt.Println("Generating", chartCRDsFilePath)
	KUSTOMIZE_BIN := os.Getenv("KUSTOMIZE_BIN")
	if KUSTOMIZE_BIN == "" {
		fmt.Println("KUSTOMIZE_BIN environment variable is not set")
		os.Exit(1)
	}
	fmt.Println("KUSTOMIZE_BIN is set to:", KUSTOMIZE_BIN)

	cmd := exec.Command(KUSTOMIZE_BIN, "build", "config/crd")
	var out bytes.Buffer
	cmd.Stdout = &out
	if err := cmd.Run(); err != nil {
		fmt.Printf("Failed to execute %s: %v\n", cmd.String(), err)
		os.Exit(1)
	}
	crdContent := out.String()

	crdContent = wrapInIfEnabled(crdContent)
	crdContent = wrapCertAnnotations(crdContent)
	crdContent = wrapWebhookConfig(crdContent)
	crdContent = wrapDeprecatedVersions(crdContent)
	crdContent = ifHelmResourcePolicyKeepAnnotation(crdContent)

	var fileCRDs *os.File
	fileCRDs, err = os.Create(chartCRDsFilePath)
	if err != nil {
		fmt.Printf("Failed to create %s: %v\n", chartCRDsFilePath, err)
		os.Exit(1)
	}
	defer fileCRDs.Close()

	for _, content := range []string{autoGenerationComment, selfSignedCertSecretTemplate, crdContent} {
		if _, err := fileCRDs.WriteString(content); err != nil {
			fmt.Printf("Failed to write to %s: %v\n", chartCRDsFilePath, err)
			os.Exit(1)
		}
	}
	fmt.Println("Successfully finished")
}

func wrapInIfEnabled(v string) string {
	return fmt.Sprintf("{{- if .Values.enabled }}\n%s\n{{- end }}\n", v)
}

const (
	// selfSignedCertSecretTemplate contains the template for the self-signed
	// certificate secret.
	// This allows users to not require cert-manager for certificates management.
	// It is embedded in manifest file containing CRD definitions because it's not
	// possible to place that in a separate file, and use the lookup function
	// (for the Secret) in the CRD definition file due to the Secret not being
	// applied yet at that time.
	// Helm hooks and their priority do not seem to help here either.
	selfSignedCertSecretTemplate = `
{{ $name := ( include "kong.webhookCertSecretName" .) }}
{{ $secret := (lookup "v1" "Secret" .Release.Namespace $name) }}
{{ $serviceName := (include "kong.webhookServiceName" .) }}
{{ $namespace := (include "kong.namespace" .) }}
{{ $domainName := ( printf "%s.%s.svc" $serviceName $namespace ) }}
{{ $domainNameClusterLocal := ( printf "%s.%s.svc.cluster.local" $serviceName $namespace ) }}
{{ $dnsNames := list ($domainName) ($domainNameClusterLocal) }}

{{ $ca := genCA "" 3650 }}
{{ $cert := genSignedCert $domainName nil $dnsNames 3650 $ca }}
{{ $certCert := $cert.Cert }}
{{ $certKey := $cert.Key }}
{{ $caCert := $ca.Cert }}
{{ if $secret }}
{{ $certCert = (index $secret.data "tls.crt" ) | b64dec }}
{{ $certKey = (index $secret.data "tls.key" ) | b64dec }}
{{ $caCert = (index $secret.data "ca.crt" ) | b64dec }}
{{- end }}

{{- if .Values.global.conversionWebhook.enabled }}
{{- if ( not .Values.global.conversionWebhook.certManager.enabled ) }}
apiVersion: v1
kind: Secret
metadata:
  labels:
    {{- include "kong.metaLabels" . | nindent 4 }}
    app.kubernetes.io/component: ko
  annotations:
    dnsNames: {{ join "," $dnsNames | quote }}
  name: {{ $name }}
  namespace: {{ template "kong.namespace" . }}
type: kubernetes.io/tls
stringData:
  ca.crt: |
    {{ $caCert | nindent 4 }}
  tls.crt: |
    {{ $certCert | nindent 4 }}
  tls.key: |
    {{ $certKey | nindent 4 }}
{{- end }}
{{- end }}
---
`
)

const (
	configurationTemplate = `  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        service:
          name: %s
          namespace: %s
          path: /convert%s
      conversionReviewVersions:
      - v1`
	annotationTemplate = `    cert-manager.io/inject-ca-from: %s/%s`
)

func annotationForKustomize() string {
	return fmt.Sprintf(
		annotationTemplate,
		"kong-system",
		"gateway-operator-serving-cert",
	)
}

func annotationForChart() string {
	return fmt.Sprintf(
		annotationTemplate,
		`{{ template "kong.namespace" . }}`,
		`{{ template "kong.webhookServiceName" . }}-serving-cert`,
	)
}

func configurationForKustomize() string {
	return fmt.Sprintf(
		configurationTemplate,
		"gateway-operator-webhook-service",
		"kong-system",
		"",
	)
}

func ifForChartCertManagerAnnotation(v string) string {
	return fmt.Sprintf("{{ if .Values.global.conversionWebhook.enabled }}\n{{ if .Values.global.conversionWebhook.certManager.enabled }}\n%s\n{{ end }}\n{{ end }}", v)
}

func ifForChartConversionSpec(v string) string {
	return fmt.Sprintf("{{ if .Values.global.conversionWebhook.enabled }}\n%s\n{{ end }}", v)
}

func fullKustomizePatchConfiguration(gr schema.GroupResource) string {
	const patchTemplate = `---
# The following patch enables a conversion webhook for the particular CRD.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: %s
  annotations:
%s
spec:
%s
`
	return fmt.Sprintf(patchTemplate, gr, annotationForKustomize(), configurationForKustomize())
}

// wrapCertAnnotations replaces the cert-manager annotation with the chart-compatible version.
func wrapCertAnnotations(content string) string {
	return strings.ReplaceAll(
		content,
		annotationForKustomize(),
		ifForChartCertManagerAnnotation(
			annotationForChart(),
		),
	)
}

// wrapWebhookConfig replaces the webhook configuration with the chart-compatible version.
func wrapWebhookConfig(content string) string {
	s := strings.ReplaceAll(
		content,
		configurationForKustomize(),
		ifForChartConversionSpec(
			fmt.Sprintf(
				configurationTemplate,
				`{{ template "kong.webhookServiceName" . }}`,
				`{{ template "kong.namespace" . }}`,
				`
{{if not .Values.global.conversionWebhook.certManager.enabled }}
        caBundle: |
          {{ $caCert | b64enc }}
{{ end }}`,
			),
		),
	)
	return s
}

func ifHelmResourcePolicyKeepAnnotation(content string) string {
	const pattern = "metadata:\n  annotations:\n"
	return strings.ReplaceAll(
		content,
		pattern,
		pattern+"{{ if .Values.keep }}\n    helm.sh/resource-policy: keep\n{{ end }}\n",
	)
}

const (
	listVersionPatternToStartWith = `  - `
	deprecatedPatternToContain    = `deprecated: true`
)

// wrapDeprecatedVersions processes the CRD YAML content and wraps deprecated version entries
// with Helm template conditionals.
func wrapDeprecatedVersions(content string) string {
	var result []string
	lines := strings.Split(content, "\n")
	for i := 0; i < len(lines); {
		line := lines[i]
		// Check if this is the start of a version entry.
		if strings.HasPrefix(line, listVersionPatternToStartWith) {
			// Find end of the potential block.
			versionEnd := findVersionEnd(lines, i)
			// Look ahead to see if this version contains "deprecated: true".
			var isDeprecated bool
			for j := i; j < versionEnd; j++ {
				if strings.Contains(lines[j], deprecatedPatternToContain) {
					isDeprecated = true
					break
				}
			}

			// Add the opening template conditional (following the existing pattern).
			if isDeprecated {
				result = append(result, "{{ if .Values.global.conversionWebhook.enabled }}")
			}
			// Add all lines of this version entry.
			for j := i; j < versionEnd; j++ {
				result = append(result, lines[j])
			}
			// Add the closing template conditional.
			if isDeprecated {
				result = append(result, "{{ end }}")
			}
			// Move to the next version.
			i = versionEnd

		} else {
			// Not a version start, just add the line and check the next one.
			result = append(result, line)
			i++
		}
	}

	return strings.Join(result, "\n")
}

// findVersionEnd finds the end of a version entry starting at startIndex.
// It returns the index of the first line that is not part of this version entry.
func findVersionEnd(lines []string, startIndex int) int {
	// A version entry ends when we encounter:
	// 1. Another version entry (line starting with "  - ").
	// 2. End of versions array (line starting with something other than spaces/tabs).
	// 3. End of file.

	numberOfLines := len(lines)
	for i := startIndex + 1; i < numberOfLines; i++ {
		line := lines[i]

		// If we hit another version entry, this version ends here.
		if strings.HasPrefix(line, listVersionPatternToStartWith) {
			return i
		}

		// If we hit a line that doesn't start with spaces (i.e., a new top-level field),
		// this version ends here.
		if len(line) > 0 && !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") {
			return i
		}
	}

	return numberOfLines
}
