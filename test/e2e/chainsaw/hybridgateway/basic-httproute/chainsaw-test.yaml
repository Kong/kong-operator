# Basic HTTPRoute test scenario
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: basic-httproute
spec:
  description: |
    This test validates that the hybrid gateway controller correctly
    processes a basic HTTPRoute with a single service backend.

  timeouts:
    apply: 120s
    assert: 300s
    delete: 120s

  # Define bindings for dynamic resource names
  # TEST_ID comes from CI (github.run_id) or defaults to 'local' for local testing
  bindings:
    - name: test_id
      value: (env('TEST_ID') || 'local')
    - name: gateway_name
      value: (join('-', ['basic', $test_id]))
    - name: proxy_ip
      value: ""
    - name: proxy_ip_cluster
      value: ""
    - name: proxy_ip_lb
      value: ""
    - name: proxy_ip
      value: ""

  steps:
    # Step 1: Create prerequisite resources
    - name: create-prerequisites
      description: Create GatewayClass, Gateway, and backend Service
      try:
        - apply:
            file: 01-prerequisites.yaml
        - apply:
            file: 00-httpbin.yaml
        # Assert test-specific resources (namespaces, service, deployment)
        - assert:
            file: 00-assert-httpbin.yaml
        # Assert Gateway resources with dynamic names
        - assert:
            file: 01-assert-gateway.yaml
      # Catch block: collect diagnostic info when assertions fail
      catch:
        - description: Get Gateway resource status
          get:
            apiVersion: gateway.networking.k8s.io/v1
            kind: Gateway
            namespace: kong
            format: yaml
        - description: Get DataPlane resources
          get:
            apiVersion: gateway-operator.konghq.com/v1beta1
            kind: DataPlane
            namespace: kong
            format: yaml
        - description: Get ControlPlane resources
          get:
            apiVersion: gateway-operator.konghq.com/v1beta1
            kind: ControlPlane
            namespace: kong
            format: yaml
        - description: Get KongRoute status
          get:
            apiVersion: configuration.konghq.com/v1alpha1
            kind: KongRoute
            namespace: kong
            format: yaml
        - description: Get Pods in kong namespace
          get:
            apiVersion: v1
            kind: Pod
            namespace: kong
            format: yaml
        - description: Describe Gateway
          describe:
            apiVersion: gateway.networking.k8s.io/v1
            kind: Gateway
            namespace: kong
            showEvents: true
        - description: Describe DataPlane
          describe:
            apiVersion: gateway-operator.konghq.com/v1beta1
            kind: DataPlane
            namespace: kong
            showEvents: true
        - description: Get events from kong namespace
          events:
            namespace: kong
        - description: Get operator logs
          podLogs:
            namespace: kong-system
            selector: control-plane=controller-manager
            tail: 100
        - description: Get all Pod logs in kong namespace
          script:
            content: |
              echo "=== Listing all Pods in kong namespace ==="
              kubectl get pods -n kong -o wide
              echo ""
              echo "=== Pod details and logs ==="
              for pod in $(kubectl get pods -n kong -o jsonpath='{.items[*].metadata.name}'); do
                echo "--- Pod: $pod ---"
                kubectl describe pod $pod -n kong | tail -50
                echo ""
                echo "--- Logs for $pod ---"
                kubectl logs $pod -n kong --all-containers --tail=50 2>/dev/null || echo "No logs available"
                echo ""
              done
    
    # Step 2: Create HTTPRoute
    - name: create-httproute
      description: Create HTTPRoute that references the Gateway
      try:
        - apply:
            file: 02-httproute.yaml
        - assert:
            file: 02-assert-httproute.yaml
    
    # Step 3: Verify generated Kong resources
    - name: verify-kong-resources
      description: Verify KongRoute, KongService, KongUpstream, and KongTarget are created
      try:
        - script:
            content: |
              kubectl wait --for=condition=Programmed --timeout=180s kongroute -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute
        # Collect bindings needed for Kong resource assertions
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: hybrid_gateway_name
                value: ($stdout)
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.namespace}'
            outputs:
              - name: hybrid_gateway_namespace
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: managedby_name
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong -o jsonpath='{.items[0].metadata.namespace}'
            outputs:
              - name: managedby_namespace
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong echo -o jsonpath='{.spec.rules[*].matches[*].path.value}' | jq -Rsc 'split(" ")'
            outputs:
              - name: route_paths_json
                value: ($stdout)
        - script:
            content: |
              OUTPUT=$(kubectl get httproute -n kong echo -o jsonpath='{.spec.rules[*].matches[*].method}')
              if [ -z "$OUTPUT" ]; then
                echo '[]'
              else
                echo "$OUTPUT" | tr -d '\n' | jq -Rsc 'split(" ")'
              fi
            outputs:
              - name: route_methods_json
                value: ($stdout)
        - script:
            content: |
              kubectl get konnectgatewaycontrolplane -n kong -l gateway-operator.konghq.com/managed-by=gateway -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: konnectgatewaycontrolplane_name
                value: ($stdout)
        - script:
            content: |
              kubectl get kongservice -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: kongservice_name
                value: ($stdout)
        - script:
            content: |
              kubectl get kongupstream -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: kongupstream_name
                value: ($stdout)
        - script:
            content: echo "kong"
            outputs:
              - name: namespace
                value: kong
              - name: strip_path
                value: true
              - name: weight
                value: 1
        # Assert Kong resources using common templates
        - assert:
            file: ../common/assertions/kongroute.yaml
        - assert:
            file: ../common/assertions/kongservice.yaml
        - assert:
            file: ../common/assertions/kongupstream.yaml
        - assert:
            file: ../common/assertions/kongtarget.yaml
    
    # Step 4: Verify data plane is configured and traffic flows
    - name: verify-data-plane
      description: Verify that the Kong data plane is properly configured and can route traffic
      try:
        # Wait for DataPlane pods to be running
        # DataPlane pods have label: gateway-operator.konghq.com/managed-by=dataplane
        - description: Wait for DataPlane proxy pods to be running
          script:
            content: |
              echo "=== Waiting for DataPlane proxy pods ==="
              for i in $(seq 1 30); do
                PODS=$(kubectl get pods -n kong -l gateway-operator.konghq.com/managed-by=dataplane -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || true)
                # Fallback to name prefix if labels are missing
                if [ -z "$PODS" ]; then
                  PODS=$(kubectl get pods -n kong -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null | grep '^dataplane-' || true)
                fi
                if [ -n "$PODS" ]; then
                  echo "Found DataPlane pods: $PODS"
                  # Wait for at least one pod to be Running
                  RUNNING=$(kubectl get pods -n kong -l gateway-operator.konghq.com/managed-by=dataplane -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' 2>/dev/null || true)
                  if [ -z "$RUNNING" ]; then
                    RUNNING=$(kubectl get pods -n kong -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.status.phase}{"\n"}{end}' 2>/dev/null | awk '/^dataplane-/{if ($2=="Running") print $1}' || true)
                  fi
                  if [ -n "$RUNNING" ]; then
                    echo "DataPlane pod running: $RUNNING"
                    exit 0
                  fi
                  echo "Pods exist but not running yet (attempt $i/30)"
                else
                  echo "No DataPlane pods found yet (attempt $i/30)"
                fi
                # Show current pods for debugging
                kubectl get pods -n kong -o wide 2>/dev/null || true
                sleep 10
              done
              echo "DataPlane pods not ready after 5 minutes"
              kubectl get dataplane -n kong -o yaml
              exit 1
        # Collect bindings for connectivity tests
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: hybrid_gateway_name
                value: ($stdout)
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.namespace}'
            outputs:
              - name: hybrid_gateway_namespace
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong -o jsonpath='{.items[0].spec.rules[0].matches[0].path.value}'
            outputs:
              - name: route_path
                value: ($stdout || '/echo')
        # Collect ingress service details for stable in-cluster access
        - script:
            content: |
              kubectl get dataplane -n kong -o jsonpath='{.items[0].status.service}'
            outputs:
              - name: dataplane_ingress_service
                value: ($stdout)
        - script:
            env:
              - name: DATAPLANE_INGRESS_SERVICE
                value: ($dataplane_ingress_service)
            content: |
              if [ -z "${DATAPLANE_INGRESS_SERVICE}" ]; then
                exit 0
              fi
              kubectl get svc ${DATAPLANE_INGRESS_SERVICE} -n kong -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
            outputs:
              - name: proxy_ip_lb
                value: ($stdout)
        - script:
            env:
              - name: DATAPLANE_INGRESS_SERVICE
                value: ($dataplane_ingress_service)
            content: |
              if [ -z "${DATAPLANE_INGRESS_SERVICE}" ]; then
                exit 0
              fi
              kubectl get svc ${DATAPLANE_INGRESS_SERVICE} -n kong -o jsonpath='{.spec.clusterIP}'
            outputs:
              - name: proxy_ip_cluster
                value: ($stdout)
        # Get the Gateway proxy IP
        - script:
            env:
              - name: GATEWAY_NAME
                value: ($hybrid_gateway_name)
              - name: GATEWAY_NAMESPACE
                value: ($hybrid_gateway_namespace)
            content: |
              set -eu
              for i in $(seq 1 30); do
                IP=$(kubectl get gateway ${GATEWAY_NAME} -n ${GATEWAY_NAMESPACE} -o jsonpath='{.status.addresses[0].value}')
                if [ -n "$IP" ]; then
                  echo "$IP"
                  exit 0
                fi
                echo "waiting for gateway address (attempt $i/30)" >&2
                sleep 10
              done
              echo "gateway address not available" >&2
              exit 1
            outputs:
              - name: proxy_ip
                value: ($stdout)
        # Test from within the cluster
        - description: Test connectivity from within the cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip)
              - name: ROUTE_PATH
                value: ($route_path)
            content: |
              POD_NAME="curl-test-$(date +%s)-$$"
              kubectl run ${POD_NAME} --image=curlimages/curl:latest --rm -i --restart=Never -- \
                curl --fail --retry 30 --retry-delay 10 --retry-all-errors -s -o /dev/null -w '%{http_code}' http://${PROXY_IP}${ROUTE_PATH}
            check:
              (contains($stdout, '200')): true
        # Test from outside the cluster
        - description: Test connectivity from outside the cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_lb || $proxy_ip)
              - name: ROUTE_PATH
                value: ($route_path)
            content: |
              echo "curling ${PROXY_IP}${ROUTE_PATH} from runner"
              curl --fail --retry 30 --retry-delay 10 --retry-all-errors -s -o /dev/null -w "%{http_code}" http://${PROXY_IP}${ROUTE_PATH}
            check:
              (contains($stdout, '200')): true
      # Catch block: collect diagnostic info when data plane verification fails
      catch:
        - description: Get HTTPRoute status
          get:
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            namespace: kong
            format: yaml
        - description: Get KongRoute status
          get:
            apiVersion: configuration.konghq.com/v1alpha1
            kind: KongRoute
            namespace: kong
            format: yaml
        - description: Get KongService status
          get:
            apiVersion: configuration.konghq.com/v1alpha1
            kind: KongService
            namespace: kong
            format: yaml
        - description: Get DataPlane pod logs
          podLogs:
            namespace: kong
            selector: gateway-operator.konghq.com/managed-by=dataplane
            tail: 200
        - description: Get operator logs
          podLogs:
            namespace: kong-system
            selector: control-plane=controller-manager
            tail: 200
        - description: Check Kong Admin API routes
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip)
            content: |
              if [ -z "${PROXY_IP}" ]; then
                echo "proxy_ip not available; skipping admin API route check"
                exit 0
              fi
              echo "=== Checking Kong data plane status ==="
              echo "DataPlane pods (label: gateway-operator.konghq.com/managed-by=dataplane):"
              kubectl get pods -n kong -l gateway-operator.konghq.com/managed-by=dataplane -o wide
              echo ""
              echo "=== All pods in kong namespace ==="
              kubectl get pods -n kong -o wide
              echo ""
              echo "=== DataPlane resources ==="
              kubectl get dataplane -n kong -o yaml
              echo ""
              echo "=== Checking Kong routes via admin API ==="
              POD=$(kubectl get pods -n kong -l gateway-operator.konghq.com/managed-by=dataplane -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
              if [ -z "$POD" ]; then
                POD=$(kubectl get pods -n kong -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null | grep '^dataplane-' | head -n1 || true)
              fi
              if [ -n "$POD" ]; then
                kubectl exec -n kong $POD -- curl -s http://localhost:8001/routes 2>/dev/null || echo "Admin API not accessible"
              else
                echo "No DataPlane proxy pod found"
              fi

    # Step 5: Update HTTPRoute
    - name: update-httproute
      description: Update HTTPRoute and verify changes propagate
      try:
        # Collect old Kong resource names before update
        - script:
            content: |
              kubectl get kongroute -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[*].metadata.name}'
            outputs:
              - name: old_kongroute_names
                value: ($stdout)
        - script:
            content: |
              kubectl get kongservice -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[*].metadata.name}'
            outputs:
              - name: old_kongservice_names
                value: ($stdout)
        - script:
            content: |
              kubectl get kongupstream -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[*].metadata.name}'
            outputs:
              - name: old_kongupstream_names
                value: ($stdout)
        - script:
            content: |
              kubectl get kongtarget -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[*].metadata.name}'
            outputs:
              - name: old_kongtarget_names
                value: ($stdout)
        # Apply the update
        - apply:
            file: 04-update-httproute.yaml
        - assert:
            file: 04-assert-updated-resources.yaml
        # Wait for old resources to be deleted
        - script:
            env:
              - name: OLD_NAMES
                value: ($old_kongroute_names)
            content: |
              if [ -n "$OLD_NAMES" ]; then
                for name in $OLD_NAMES; do
                  echo "Waiting for old KongRoute $name to be deleted..."
                  kubectl wait --for=delete kongroute/$name -n kong --timeout=60s || true
                done
              fi
        - script:
            env:
              - name: OLD_NAMES
                value: ($old_kongservice_names)
            content: |
              if [ -n "$OLD_NAMES" ]; then
                for name in $OLD_NAMES; do
                  echo "Waiting for old KongService $name to be deleted..."
                  kubectl wait --for=delete kongservice/$name -n kong --timeout=60s || true
                done
              fi
        - script:
            env:
              - name: OLD_NAMES
                value: ($old_kongupstream_names)
            content: |
              if [ -n "$OLD_NAMES" ]; then
                for name in $OLD_NAMES; do
                  echo "Waiting for old KongUpstream $name to be deleted..."
                  kubectl wait --for=delete kongupstream/$name -n kong --timeout=60s || true
                done
              fi
        - script:
            env:
              - name: OLD_NAMES
                value: ($old_kongtarget_names)
            content: |
              if [ -n "$OLD_NAMES" ]; then
                for name in $OLD_NAMES; do
                  echo "Waiting for old KongTarget $name to be deleted..."
                  kubectl wait --for=delete kongtarget/$name -n kong --timeout=60s || true
                done
              fi
        # Wait for new KongRoute to be programmed
        - script:
            content: |
              kubectl wait --for=condition=Programmed --timeout=60s kongroute -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute
        # Collect bindings for Kong resource assertions
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: hybrid_gateway_name
                value: ($stdout)
        - script:
            content: |
              kubectl get gateway -n kong -o jsonpath='{.items[0].metadata.namespace}'
            outputs:
              - name: hybrid_gateway_namespace
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: managedby_name
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong -o jsonpath='{.items[0].metadata.namespace}'
            outputs:
              - name: managedby_namespace
                value: ($stdout)
        - script:
            content: |
              kubectl get httproute -n kong echo -o jsonpath='{.spec.rules[*].matches[*].path.value}' | jq -Rsc 'split(" ")'
            outputs:
              - name: route_paths_json
                value: ($stdout)
        - script:
            content: |
              OUTPUT=$(kubectl get httproute -n kong echo -o jsonpath='{.spec.rules[*].matches[*].method}')
              if [ -z "$OUTPUT" ]; then
                echo '[]'
              else
                echo "$OUTPUT" | tr -d '\n' | jq -Rsc 'split(" ")'
              fi
            outputs:
              - name: route_methods_json
                value: ($stdout)
        - script:
            content: echo "kong"
            outputs:
              - name: namespace
                value: kong
              - name: strip_path
                value: false
              - name: weight
                value: 1
        # Collect Kong resource names after reconciliation
        - script:
            content: |
              kubectl get konnectgatewaycontrolplane -n kong -l gateway-operator.konghq.com/managed-by=gateway -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: konnectgatewaycontrolplane_name
                value: ($stdout)
        - script:
            content: |
              kubectl get kongservice -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: kongservice_name
                value: ($stdout)
        - script:
            content: |
              kubectl get kongupstream -n kong -l gateway-operator.konghq.com/managed-by=HTTPRoute -o jsonpath='{.items[0].metadata.name}'
            outputs:
              - name: kongupstream_name
                value: ($stdout)
        # Verify Kong resources are updated
        - assert:
            file: ../common/assertions/kongroute.yaml
        - assert:
            file: ../common/assertions/kongservice.yaml
        - assert:
            file: ../common/assertions/kongupstream.yaml
        - assert:
            file: ../common/assertions/kongtarget.yaml
        # Additional assertion for methods field (specific to this step)
        - assert:
            resource:
              apiVersion: configuration.konghq.com/v1alpha1
              kind: KongRoute
              metadata:
                namespace: kong
              spec:
                methods: (parse_json($route_methods_json))
        # Test the updated routes
        - script:
            content: |
              set -eu
              for i in $(seq 1 30); do
                IP=$(kubectl get gateway -n kong -o jsonpath='{.items[0].status.addresses[0].value}')
                if [ -n "$IP" ]; then
                  echo "$IP"
                  exit 0
                fi
                echo "waiting for gateway address (attempt $i/30)" >&2
                sleep 10
              done
              echo "gateway address not available" >&2
              exit 1
            outputs:
              - name: proxy_ip
                value: ($stdout)
        
        # Create a test pod for in-cluster tests
        - script:
            content: |
              kubectl run curl-test-pod --image=curlimages/curl:latest --restart=Never -- sleep 3600
              kubectl wait --for=condition=Ready pod/curl-test-pod --timeout=60s
        
        # Test from within the cluster
        - description: Test GET /get endpoint from within cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip_lb || $proxy_ip)
            content: |
              kubectl exec curl-test-pod -- curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -w '%{http_code}' -o /dev/null http://${PROXY_IP}/get
            check:
              (contains($stdout, '200')): true
        
        - description: Test POST /post endpoint from within cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip_lb || $proxy_ip)
            content: |
              kubectl exec curl-test-pod -- curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -w '%{http_code}' -o /dev/null -X POST http://${PROXY_IP}/post
            check:
              (contains($stdout, '200')): true
        
        - description: Test PUT /put endpoint from within cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip_lb || $proxy_ip)
            content: |
              kubectl exec curl-test-pod -- curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -w '%{http_code}' -o /dev/null -X PUT http://${PROXY_IP}/put
            check:
              (contains($stdout, '200')): true
        
        - description: Test PATCH /patch endpoint from within cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip_lb || $proxy_ip)
            content: |
              kubectl exec curl-test-pod -- curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -w '%{http_code}' -o /dev/null -X PATCH http://${PROXY_IP}/patch
            check:
              (contains($stdout, '200')): true
        
        - description: Test DELETE /delete endpoint from within cluster
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_cluster || $proxy_ip_lb || $proxy_ip)
            content: |
              kubectl exec curl-test-pod -- curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -w '%{http_code}' -o /dev/null -X DELETE http://${PROXY_IP}/delete
            check:
              (contains($stdout, '200')): true
        
        # Delete the test pod
        - script:
            content: |
              kubectl delete pod curl-test-pod --ignore-not-found=true --wait=false
        
        # Test from outside the cluster
        - description: Test GET /get endpoint from host
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_lb || $proxy_ip)
            content: |
              curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -o /dev/null -w "%{http_code}" http://${PROXY_IP}/get
            check:
              (contains($stdout, '200')): true
        
        - description: Test POST /post endpoint from host
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_lb || $proxy_ip)
            content: |
              curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -o /dev/null -w "%{http_code}" -X POST http://${PROXY_IP}/post
            check:
              (contains($stdout, '200')): true
        
        - description: Test PUT /put endpoint from host
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_lb || $proxy_ip)
            content: |
              curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -o /dev/null -w "%{http_code}" -X PUT http://${PROXY_IP}/put
            check:
              (contains($stdout, '200')): true
        
        - description: Test PATCH /patch endpoint from host
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip_lb || $proxy_ip)
            content: |
              curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -o /dev/null -w "%{http_code}" -X PATCH http://${PROXY_IP}/patch
            check:
              (contains($stdout, '200')): true
        
        - description: Test DELETE /delete endpoint from host
          script:
            env:
              - name: PROXY_IP
                value: ($proxy_ip)
            content: |
              curl --fail --retry 10 --retry-delay 5 --retry-all-errors -s -o /dev/null -w "%{http_code}" -X DELETE http://${PROXY_IP}/delete
            check:
              (contains($stdout, '200')): true
    
